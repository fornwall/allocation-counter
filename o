    // Verify that no memory allocations are made:
    let info = allocation_counter::measure(|| {
        code_that_should_not_allocate();
    });
    assert_eq!(info.count_total, 0);

    // Let's use a case where some allocations are expected.
    let info = allocation_counter::measure(|| {
        code_that_should_allocate_a_little();
    });

    // Using a lower bound can help track behaviour over time:
    assert!((500..600).contains(&info.count_total));
    assert!((10_000..20_000).contains(&info.bytes_total));

    // Limit peak memory usage:
    assert!((100..200).contains(&info.count_max));
    assert!((1_000..2_000).contains(&info.bytes_max));

    // We don't want any leaks:
    assert_eq!(0, info.count_current);
    assert_eq!(0, info.bytes_current);

    // It's possible to opt out of counting allocations
    // for certain parts of the code flow:
    let info = allocation_counter::measure(|| {
        code_that_should_not_allocate();
        allocation_counter::avoid_counting(|| {
            external_code_that_should_not_be_tested();
        });
        code_that_should_not_allocate();
    });
    assert_eq!(0, info.count_total);

